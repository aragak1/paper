{"url": "http://exercise.acmcoder.com/comp_test?paperId=137", "content": [{"answer": "D", "type": "单选", "name": "<p>在一个游戏的任务中,玩家需要进入1个山洞,取得宝石,之后回到入口.</p><p>山洞的地图如下:</p><p>&nbsp; &nbsp; S--------------------T</p><p>S是入口</p><p>T处有宝箱,打开宝箱之后可能得到的物品有:</p><p>1)宝石,出现概率为5%.</p><p>2)魔法券.出现概率为50%.玩家每消耗一个魔法券,可以直接传送到入口S.</p><p>3)什么也没有,概率为45%.</p><p>S到T的距离为1.</p><p>每次玩家回到S之后,宝箱T的状态会重置,再次进入山洞可以重新打开宝箱获得物品.</p><p>玩家的任务是到达T获取宝石之后回到入口S.如果到达T之后没有获得宝石,可以走出山洞之后</p><p>再进入反复刷.</p><p>问题:玩家完成任务所走路程的数学期望是( &nbsp; &nbsp;)</p><p><br></p>", "options": [{"option_name": "A", "content": "40"}, {"option_name": "B", "content": "25"}, {"option_name": "C", "content": "35"}, {"option_name": "D", "content": "30"}]}, {"answer": "D", "type": "单选", "name": "<p>不考虑任何编译器优化(如:NRVO),下述代码的第10行会发生</p><pre class=\"brush:cpp;toolbar:false\">#include&nbsp;&lt;stdio.h&gt;//1\r\nclass&nbsp;B//2\r\n{//3\r\n};//4\r\nB&nbsp;func(const&nbsp;B&amp;&nbsp;rhs){//5\r\n&nbsp;&nbsp;return&nbsp;rhs;//6\r\n}//7\r\nint&nbsp;main(int&nbsp;argc,char&nbsp;**argv){//8\r\n&nbsp;&nbsp;B&nbsp;b1,b2;//9\r\n&nbsp;&nbsp;b2=func(b1);//10\r\n}//11</pre><p><br></p>", "options": [{"option_name": "A", "content": "一次默认构造函数,一次拷贝构造函数,一次析构函数,一次(拷贝赋值运算符)operator="}, {"option_name": "B", "content": "二次拷贝构造函数,一次析构函数"}, {"option_name": "C", "content": "一次(拷贝赋值运算符)operator=,一次析构函数"}, {"option_name": "D", "content": "一次拷贝构造函数,一次析构函数,一次(拷贝赋值运算符)operator="}]}, {"answer": "C", "type": "单选", "name": "<p>下面关于TCP的描述,错误的是( &nbsp; &nbsp;)</p>", "options": [{"option_name": "A", "content": "TCP是一种面向连接的协议,给用户进程提供可靠的全双工的字节流"}, {"option_name": "B", "content": "TCP客户端和服务器之间建立连接需要经过3次握手"}, {"option_name": "C", "content": "只要有一方主动关闭连接后,这个TCP连接就结束了"}, {"option_name": "D", "content": "TCP在传输数据过程中必须保持着连接,这个连接会给通信过程增加开销"}]}, {"answer": "B", "type": "单选", "name": "<p>从根开始按层次(第0层-&gt;第1层-&gt;第2层)遍历一颗二叉树,需要使用什么辅助数据结构?( &nbsp; &nbsp;)</p>", "options": [{"option_name": "A", "content": "heap"}, {"option_name": "B", "content": "queue"}, {"option_name": "C", "content": "binary tree"}, {"option_name": "D", "content": "stack"}]}, {"answer": "B", "type": "单选", "name": "<p>关于重载和多态正确的是</p>", "options": [{"option_name": "A", "content": "如果父类和子类都有相同的方法,参数个数不同,将子类对象赋给父类后,由于子类继承于父类,所以使用父类指针调用父类方法时,实际调用的是子类的方法"}, {"option_name": "B", "content": "选项全部都不正确"}, {"option_name": "C", "content": "重载和多态在C++面向对象编程中经常用到的方法,都只在实现子类的方法时才会使用"}, {"option_name": "D", "content": "<p>class A{</p><p> void test(float a){cout<<\"1\";}</p><p>};</p><p>class B:public A{</p><p> void test(int b){cout<<\"2\";}</p><p>};</p><p>A *a=new A;</p><p>B *b=new B;</p><p>a=b;</p><p>a.test(1.1);</p><p>结果是1</p>"}]}, {"answer": "B", "type": "单选", "name": "<pre class=\"brush:cpp;toolbar:false\">int&nbsp;a=0;\r\nclass&nbsp;someClass{\r\n&nbsp;&nbsp;&nbsp;int&nbsp;b;\r\n&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;c;\r\n};\r\nint&nbsp;main(){\r\n&nbsp;&nbsp;&nbsp;int&nbsp;d=0;\r\n&nbsp;&nbsp;&nbsp;someClass&nbsp;*p=new&nbsp;someClass();\r\n&nbsp;&nbsp;&nbsp;return&nbsp;0;\r\n}</pre><p>关于以上代码中的变量在内存中的存储位置描述不正确的是( &nbsp; &nbsp;)<br></p>", "options": [{"option_name": "A", "content": "b存在堆区"}, {"option_name": "B", "content": "c存在堆区"}, {"option_name": "C", "content": "d存在栈区"}, {"option_name": "D", "content": "<p>a存在全局变量区</p>"}]}, {"answer": "C", "type": "单选", "name": "<p>快速排序在下面哪种情况下优势最明显( &nbsp; &nbsp;)</p>", "options": [{"option_name": "A", "content": "数据有多个相同数值"}, {"option_name": "B", "content": "数据基本有序"}, {"option_name": "C", "content": "数据基本无序"}, {"option_name": "D", "content": "数据无任何相同数值"}]}, {"answer": "C", "type": "单选", "name": "<p>典型的创建Windows窗口过程的流程为:( &nbsp; &nbsp;)</p>", "options": [{"option_name": "A", "content": "注册窗口类->创建窗口->更新窗口->显示窗口->消息循环"}, {"option_name": "B", "content": "创建窗口->注册窗口类->显示窗口->更新窗口->消息循环"}, {"option_name": "C", "content": "注册窗口类->创建窗口->显示窗口->更新窗口->消息循环"}, {"option_name": "D", "content": "创建窗口->注册窗口类->更新窗口->显示窗口->消息循环"}]}, {"answer": "C", "type": "单选", "name": "<p>现有两堆硬币,小明和小亮玩游戏,每次每人只能从其中一堆中取走1个或2个硬币,最后将硬币取完者算作胜利,当两堆硬币的个数分别是12,13时,小明应该如何安排策略才能必定获得胜利?</p>", "options": [{"option_name": "A", "content": "安排小亮先取硬币"}, {"option_name": "B", "content": "小明或小亮均一定必胜"}, {"option_name": "C", "content": "安排自己先取硬币"}, {"option_name": "D", "content": "不可能必胜"}]}, {"answer": "A", "type": "单选", "name": "<p>下面哪种数据结构最适合创建一个优先级队列( &nbsp; &nbsp;)</p>", "options": [{"option_name": "A", "content": "堆"}, {"option_name": "B", "content": "双向链表"}, {"option_name": "C", "content": "单向链表"}, {"option_name": "D", "content": "栈"}]}, {"answer": "C", "type": "单选", "name": "<p>下列各树形结构中,哪些是平衡二叉查找树:</p>", "options": [{"option_name": "A", "content": "             4<br>\r\n                / \\<br>\r\n               3   5<br>\r\n              /     \\<br>\r\n             2       8<br>\r\n            /         \\<br>\r\n           1           9    "}, {"option_name": "B", "content": "              7<br>\r\n                 / \\<br>\r\n                2   8<br>\r\n               / \\<br>\r\n              1   4<br>\r\n                 / \\<br>\r\n                3   5    "}, {"option_name": "C", "content": "               5<br>\r\n                 /   \\<br>\r\n                2     8<br>\r\n               / \\   /<br>\r\n              1   4 7<br>\r\n                 /<br>\r\n                3    "}, {"option_name": "D", "content": "<p>                7<br>\r\n                  /   \\<br>\r\n                 2     8<br>\r\n                / \\   /<br>\r\n               1   4 6<br>\r\n                  /<br>\r\n                 3    </p>"}]}, {"answer": "D", "type": "单选", "name": "<p>某个大型的网络游戏网站,现有几亿用户,为了实时获取前十名游戏分数最高的玩家,使用以下哪个排序算法比较合理( &nbsp; &nbsp;)</p>", "options": [{"option_name": "A", "content": "基数排序"}, {"option_name": "B", "content": "快速排序"}, {"option_name": "C", "content": "二叉排序"}, {"option_name": "D", "content": "堆排序"}]}, {"answer": "B", "type": "单选", "name": "<p>下面代码的输出结果是()<br></p><pre class=\"brush:cpp;toolbar:false\">int&nbsp;main(){\r\n&nbsp;&nbsp;&nbsp;int&nbsp;pid;\r\n&nbsp;&nbsp;&nbsp;int&nbsp;num=1;\r\n&nbsp;&nbsp;&nbsp;pid=fork();\r\n&nbsp;&nbsp;&nbsp;if(pid&gt;0){\r\n&nbsp;&nbsp;&nbsp;num++;\r\n&nbsp;&nbsp;&nbsp;printf(\"in&nbsp;parent:num:%d&nbsp;addr:%x\\n\",num,&amp;num);\r\n&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;else&nbsp;if(pid==0){\r\n&nbsp;&nbsp;&nbsp;printf(\"in&nbsp;child:num:%d&nbsp;addr:%x\\n\",num,&amp;num);\r\n&nbsp;&nbsp;&nbsp;}\r\n}</pre><p><br></p>", "options": [{"option_name": "A", "content": "父子进程中输出的num相同,num地址不相同"}, {"option_name": "B", "content": "父子进程中输出的num不同,num地址相同"}, {"option_name": "C", "content": "父子进程中输出的num相同,num地址也相同"}, {"option_name": "D", "content": "父子进程中输出的num不同,num地址不相同"}]}, {"answer": "ABD", "type": "不定项选择", "name": "<p>关于进程和线程描述正确的是( &nbsp; &nbsp;)</p>", "options": [{"option_name": "A", "content": "关于进程和线程描述正确的是()"}, {"option_name": "B", "content": "线程不拥有系统资源,但可以访问隶属于进程的资源"}, {"option_name": "C", "content": "在创建或销毁进程时,系统开销明显大于创建或销毁线程时开销"}, {"option_name": "D", "content": "进程是调度和拥有资源的基本单位"}, {"option_name": "E", "content": "不仅进程可以并发执行,同一个进程的多个线程之间也可以并发执行"}]}, {"answer": "B", "type": "单选", "name": "<p>下面( &nbsp; &nbsp;)哪个函数返回的有效句柄用完后不需要CloseHandle</p>", "options": [{"option_name": "A", "content": "CreateThread"}, {"option_name": "B", "content": "GetCurrentProcess"}, {"option_name": "C", "content": "OpenProcess"}, {"option_name": "D", "content": "CreateFile"}]}, {"answer": "C", "type": "单选", "name": "<p>有A,B,C,D,E五个字符,出现的频率分别为2,5,3,3,4,由A,B,C,D,E生成的最优二叉树中,该树的带权路径长是多少( &nbsp; &nbsp;)</p>", "options": [{"option_name": "A", "content": "35"}, {"option_name": "B", "content": "49"}, {"option_name": "C", "content": "39"}, {"option_name": "D", "content": "45"}]}, {"answer": "C", "type": "单选", "name": "<pre class=\"brush:cpp;toolbar:false\">#include&lt;stdio.h&gt;\r\nint&nbsp;main()\r\n{\r\n&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;i=7;\r\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j=0;\r\n&nbsp;&nbsp;&nbsp;&nbsp;for(;i&gt;0;i-=3)\r\n&nbsp;&nbsp;&nbsp;&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++j;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%d\\n\",j);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;\r\n}</pre><p>问该程序的输出是多少?<br></p>", "options": [{"option_name": "A", "content": "2"}, {"option_name": "B", "content": "死循环"}, {"option_name": "C", "content": "173"}, {"option_name": "D", "content": "172"}]}, {"answer": "AD", "type": "不定项选择", "name": "<p>假设MySQL数据库表:</p><p>create table T{</p><p>k int unsigned not null auto_increment,</p><p>a date,</p><p>b varchar(24),</p><p>c int,d varchar(24),</p><p>primary key(k),unique key a_index (a DESC,b DESC),</p><p>key k1(b),key k2(c),key k3(d));</p><p>如下哪些sql语句查询能较好的利用索引?( &nbsp; &nbsp;)</p><p><br></p>", "options": [{"option_name": "A", "content": "select b from WHERE b like \"aaa%\"; "}, {"option_name": "B", "content": "select a,b from T WHERE a=\"2015-10-25\" ORDER BY b ASC,c ASC;"}, {"option_name": "C", "content": "select a,b,c from T WHERE a=\"2015-10-25\" ORDER BY b ASC;"}, {"option_name": "D", "content": "<p>select a,b,c from T WHERE a=\"2015-10-25\" ORDER BY a,b;</p>"}]}, {"answer": "D", "type": "单选", "name": "<p>invalidateRect的作用是()</p>", "options": [{"option_name": "A", "content": "擦除一个矩形区域"}, {"option_name": "B", "content": "删除一个矩形"}, {"option_name": "C", "content": "使一个矩形区域变为无效,从而释放部分GDI资源"}, {"option_name": "D", "content": "使一个矩形区域变为无效,从而可以重绘"}]}, {"answer": "D", "type": "单选", "name": "<p>以下代码段有问题的是( &nbsp; &nbsp;)</p>", "options": [{"option_name": "A", "content": "void func1(char *e){  char *p1;  p1=malloc(100);  sprintf(p1,error:\"%s"}, {"option_name": "B", "content": "int func2(char *filename)  {    FILE *fp;    int key;    fp=fopen(filename,\"r\");    fscanf(fp,\"%d\",&key);    return key;   }"}, {"option_name": "C", "content": "void func3(char *info){  char *p,*pp;  p=malloc(100);  pp=p;  free(p);  sprintf(pp,*info:\"%s"}, {"option_name": "D", "content": "选项全部都正确"}]}], "company": "搜狗", "name": "搜狗2016 C++工程师笔试题", "id": "137"}