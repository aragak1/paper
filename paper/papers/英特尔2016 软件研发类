{"year": "2016", "url": "http://exercise.acmcoder.com/comp_test?paperId=116", "content": [{"answer": "B", "type": "单选", "name": "<p>在一个以 h 为头指针的单循环链中，p 指针指向链尾结点的条件是( )。</p>", "options": [{"option_name": "A", "content": "p->next==NULL"}, {"option_name": "B", "content": "p->next==h"}, {"option_name": "C", "content": "p->next->next==h"}, {"option_name": "D", "content": "p->data==-1"}]}, {"answer": "D", "type": "单选", "name": "<p>以下不能正确定义二维数组的选项是______。</p>", "options": [{"option_name": "A", "content": "int a[2][2]={{1},{2}};"}, {"option_name": "B", "content": "int a[][2]={1,2,3,4};"}, {"option_name": "C", "content": "int a[2][2]={{1},2,3};"}, {"option_name": "D", "content": "int a[2][]={{1,2},{3,4}};"}]}, {"answer": "B", "type": "单选", "name": "<p>交换机工作在OSI七层的哪一层？（ ）</p>", "options": [{"option_name": "A", "content": "一层"}, {"option_name": "B", "content": "二层"}, {"option_name": "C", "content": "三层"}, {"option_name": "D", "content": "三层以上"}]}, {"answer": "C", "type": "单选", "name": "<p>以下排序算法中是稳定的且时间复杂度最小的是：</p>", "options": [{"option_name": "A", "content": "bubble sort"}, {"option_name": "B", "content": "heap sort"}, {"option_name": "C", "content": "merge sort"}, {"option_name": "D", "content": "quick sort"}, {"option_name": "E", "content": "shell sort"}]}, {"answer": "A", "type": "单选", "name": "<p>2^100 mod 7 =____</p>", "options": [{"option_name": "A", "content": "2"}, {"option_name": "B", "content": "3"}, {"option_name": "C", "content": "4"}, {"option_name": "D", "content": "5"}]}, {"answer": "A", "type": "单选", "name": "<p>n从1开始，每个操作可以选择对n加1或者对n加倍。若想获得整数2013，最少需要多少个操作：( )</p>", "options": [{"option_name": "A", "content": "18"}, {"option_name": "B", "content": "24"}, {"option_name": "C", "content": "21"}, {"option_name": "D", "content": "不可能"}]}, {"answer": "C", "type": "单选", "name": "<p>各个路由协议衡量路由的好坏标准是（ ）。</p>", "options": [{"option_name": "A", "content": "路由"}, {"option_name": "B", "content": "路由器优先级"}, {"option_name": "C", "content": "路由权"}, {"option_name": "D", "content": "包转发率"}]}, {"answer": "A", "type": "单选", "name": "<p>判断有向图是否存在回路，利用( )方法最佳&nbsp;</p>", "options": [{"option_name": "A", "content": "拓扑排序"}, {"option_name": "B", "content": "求最短路径"}, {"option_name": "C", "content": "求关键路径"}, {"option_name": "D", "content": "广度优先遍历"}]}, {"answer": "A", "type": "单选", "name": "<p>初始序列为1 8 6 2 5 4 7 3的一组数采用堆排序，当建堆(小根堆)完毕时，堆所对应的二叉树中序遍历序列为：( )</p>", "options": [{"option_name": "A", "content": "8 3 2 5 1 6 4 7"}, {"option_name": "B", "content": "3 2 8 5 1 4 6 7"}, {"option_name": "C", "content": "3 8 2 5 1 6 7 4"}, {"option_name": "D", "content": "8 2 3 5 1 4 7 6"}]}, {"answer": "A", "type": "单选", "name": "<p>请阅读该程序：<br></p><pre class=\"brush:java;toolbar:false\">PROCEDURE&nbsp;bubblesort(r,n)\r\nBEGIN\r\n&nbsp;&nbsp;i:=1;&nbsp;m:=n-1;&nbsp;flag:=1;\r\n&nbsp;&nbsp;WHILE&nbsp;(i&lt;=m)&nbsp;AND&nbsp;(flag=1)&nbsp;DO\r\n&nbsp;&nbsp;&nbsp;BEGIN\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag:=0;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FOR&nbsp;j:=1&nbsp;TO&nbsp;m&nbsp;DO\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IF&nbsp;r[j].key&gt;r[j+1].key&nbsp;THEN\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BEGIN\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flag:=1;&nbsp;t:=r[j];&nbsp;r[j]:=r[j+1];&nbsp;r[j+1]:=t\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;END;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i:=i+1;m:=m-1\r\n&nbsp;&nbsp;&nbsp;END;\r\nEND.</pre><p>该分类算法稳定吗？( &nbsp;)</p>", "options": [{"option_name": "A", "content": "稳定"}, {"option_name": "B", "content": "不稳定"}, {"option_name": "C", "content": "不确定"}]}, {"answer": "D", "type": "单选", "name": "<p>若要求在if后一对圆括号中表示a不等于0的关系，则能正确表示这一关系的表达式为______。</p>", "options": [{"option_name": "A", "content": "a<>0"}, {"option_name": "B", "content": "!a"}, {"option_name": "C", "content": "a=0"}, {"option_name": "D", "content": "a"}]}, {"answer": "C", "type": "单选", "name": "<p>以下程序的输出结果是______。<br></p><pre class=\"brush:java;toolbar:false\">#include&nbsp;&lt;stdio.h&gt;\r\nint&nbsp;main()\r\n{&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,a[10];\r\n&nbsp;&nbsp;&nbsp;&nbsp;for(i=9;i&gt;=0;i--)&nbsp;&nbsp;a[i]=10-i;\r\n&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%d%d%d\",a[2],a[5],a[8]);\r\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;\r\n}</pre><p><br></p>", "options": [{"option_name": "A", "content": "258"}, {"option_name": "B", "content": "741"}, {"option_name": "C", "content": "852"}, {"option_name": "D", "content": "369"}]}, {"answer": "B", "type": "单选", "name": "<p>有定义语句：</p><p>int b;</p><p>char c[10];</p><p>则正确的输入语句是______。</p>", "options": [{"option_name": "A", "content": "scanf(\"%d%s\",&b,&c);"}, {"option_name": "B", "content": "scanf(\"%d%s\",&b,c);"}, {"option_name": "C", "content": "scanf(\"%d%s\",b,c);"}, {"option_name": "D", "content": "scanf(\"%d%s\",b,&c);"}]}, {"answer": "D", "type": "单选", "name": "<p>下面程序的输出是什么？<br></p><pre class=\"brush:java;toolbar:false\">#include&lt;stdio.h&gt;\r\n#include&lt;string.h&gt;\r\n#include&nbsp;&lt;pthread.h&gt;\r\n&nbsp;&nbsp;\r\nvoid*&nbsp;print1(void*&nbsp;data){\r\n&nbsp;&nbsp;&nbsp;&nbsp;printf(\"1&nbsp;\");\r\n}\r\n&nbsp;&nbsp;\r\nvoid*&nbsp;print2(void*&nbsp;data){\r\n&nbsp;&nbsp;&nbsp;&nbsp;printf(\"2&nbsp;\");\r\n}\r\n&nbsp;\r\nvoid*&nbsp;print3(void*&nbsp;data){\r\n&nbsp;&nbsp;&nbsp;&nbsp;printf(\"3&nbsp;\");\r\n}\r\n&nbsp;\r\nint&nbsp;main(void){\r\n&nbsp;&nbsp;&nbsp;&nbsp;pthread_t&nbsp;t,t1,t2;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;t,0,print1,NULL);\r\n&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;t1,0,print2,NULL);\r\n&nbsp;&nbsp;&nbsp;&nbsp;pthread_create(&amp;t2,0,print3,NULL);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(t,NULL);\r\n&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(t1,NULL);\r\n&nbsp;&nbsp;&nbsp;&nbsp;pthread_join(t2,NULL);\r\n&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\\\n\");\r\n}</pre><p><br></p>", "options": [{"option_name": "A", "content": "1 2 3"}, {"option_name": "B", "content": "1 3 2"}, {"option_name": "C", "content": "3 2 1"}, {"option_name": "D", "content": "不确定"}]}, {"answer": "B", "type": "单选", "name": "<p>不属于冯诺依曼体系结构必要组成部分是：( )</p>", "options": [{"option_name": "A", "content": "CPU"}, {"option_name": "B", "content": "Cache"}, {"option_name": "C", "content": "c"}, {"option_name": "D", "content": "键盘"}]}, {"answer": "C", "type": "单选", "name": "<p>在嵌套使用if语句时，C语言规定else总是______。</p>", "options": [{"option_name": "A", "content": "和之前与其具有相同缩进位置的if配对"}, {"option_name": "B", "content": "和之前与其最近的if配对"}, {"option_name": "C", "content": "和之前与其最近的且不带else的if配对"}, {"option_name": "D", "content": "和之前的第一个if配对"}]}, {"answer": "C", "type": "单选", "name": "<p>若一棵具有n(n&gt;0)个结点的二叉树的先序序列与后序序列正好相反，则该二叉树一定？</p>", "options": [{"option_name": "A", "content": "结点均无左孩子的二叉树"}, {"option_name": "B", "content": "结点均无右孩子的二叉树"}, {"option_name": "C", "content": "高度为n的二叉树"}, {"option_name": "D", "content": "存在度为2的结点的二叉树"}]}, {"answer": "C", "type": "单选", "name": "<p>有一台4核CPU的服务器，上面运行着1种在线服务。如果该在线服务处理一个请求在非独占IO上的等待时间和CPU计算上消耗的时间比为2:1，假定IO带宽充足，那么至少开（）个线程能最大化性能地使用该服务器？</p>", "options": [{"option_name": "A", "content": "4"}, {"option_name": "B", "content": "8"}, {"option_name": "C", "content": "12"}, {"option_name": "D", "content": "线程越多越好"}]}, {"answer": "C", "type": "单选", "name": "<p>下列代码试图打印数字1-9的全排列组合。</p><pre class=\"brush:java;toolbar:false\">#include&nbsp;\"stdio.h\"\r\n#define&nbsp;N&nbsp;9\r\nint&nbsp;x[N];\r\nint&nbsp;count&nbsp;=&nbsp;0;\r\n&nbsp;\r\nvoid&nbsp;dump()&nbsp;{\r\n&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;0;\r\n&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;N;&nbsp;i++)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%d\",&nbsp;x[i]);\r\n&nbsp;&nbsp;}\r\n&nbsp;&nbsp;printf(\"\\\\n\");\r\n}\r\n&nbsp;\r\nvoid&nbsp;swap(int&nbsp;a,&nbsp;int&nbsp;b)&nbsp;{\r\n&nbsp;&nbsp;int&nbsp;t&nbsp;=&nbsp;x[a];\r\n&nbsp;&nbsp;x[a]&nbsp;=&nbsp;x[b];\r\n&nbsp;&nbsp;x[b]&nbsp;=&nbsp;t;\r\n}\r\n&nbsp;\r\nvoid&nbsp;run(int&nbsp;n)&nbsp;{\r\n&nbsp;&nbsp;int&nbsp;i;\r\n&nbsp;&nbsp;if&nbsp;(N&nbsp;-&nbsp;1&nbsp;==&nbsp;n)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;dump();\r\n&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;++;\r\n&nbsp;&nbsp;&nbsp;&nbsp;return;\r\n&nbsp;&nbsp;}\r\n&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;___;&nbsp;i&nbsp;&lt;&nbsp;N;&nbsp;i++)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;swap(___,&nbsp;i);\r\n&nbsp;&nbsp;&nbsp;&nbsp;run(n&nbsp;+&nbsp;1);\r\n&nbsp;&nbsp;&nbsp;&nbsp;swap(___,&nbsp;i);\r\n&nbsp;&nbsp;}\r\n}\r\n&nbsp;\r\nint&nbsp;main()&nbsp;{\r\n&nbsp;&nbsp;int&nbsp;i;\r\n&nbsp;&nbsp;for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;N;&nbsp;i++)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;x[i]&nbsp;=&nbsp;i&nbsp;+&nbsp;1;\r\n&nbsp;&nbsp;}\r\n&nbsp;&nbsp;run(0);\r\n&nbsp;&nbsp;printf(\"*&nbsp;Total:&nbsp;%d\\\\n\",&nbsp;count);\r\n}</pre><p>其中run函数中缺失的部分应该依次为：</p>", "options": [{"option_name": "A", "content": "n+1, n, n+1"}, {"option_name": "B", "content": "n+1, n, n"}, {"option_name": "C", "content": "n, n, n"}, {"option_name": "D", "content": "n, n+1, n+1"}, {"option_name": "E", "content": "n+1, n+1, n+1"}, {"option_name": "F", "content": "n, n, n+1"}]}, {"answer": "C", "type": "单选", "name": "<p>在32位系统环境，编译选项为4字节对齐，那么sizeof(A)和sizeof(B)是：&nbsp;<br></p><pre class=\"brush:java;toolbar:false\">struct&nbsp;A\r\n{\r\n&nbsp;int&nbsp;a;\r\n&nbsp;short&nbsp;b;\r\n&nbsp;int&nbsp;c;\r\n&nbsp;char&nbsp;d;\r\n};\r\nstruct&nbsp;B\r\n{\r\n&nbsp;int&nbsp;a;\r\n&nbsp;short&nbsp;b;\r\n&nbsp;char&nbsp;c;\r\n&nbsp;int&nbsp;d;\r\n};</pre>", "options": [{"option_name": "A", "content": "16,16"}, {"option_name": "B", "content": "13,12"}, {"option_name": "C", "content": "16,12"}, {"option_name": "D", "content": "11,16"}]}], "company": "Intel", "name": "英特尔2016 软件研发类", "id": "116"}