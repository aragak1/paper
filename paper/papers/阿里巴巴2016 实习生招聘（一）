{"year": "2016", "url": "http://exercise.acmcoder.com/comp_test?paperId=77", "content": [{"answer": "E", "type": "单选", "name": "<p>有无限的水源,一个5L无刻度桶和一个7L无刻度桶,则只利用这两个无刻度桶,将不能获得()L水</p>", "options": [{"option_name": "A", "content": "2<br>"}, {"option_name": "B", "content": "3<br>"}, {"option_name": "C", "content": "6<br>"}, {"option_name": "D", "content": "8<br>"}, {"option_name": "E", "content": "11<br>"}, {"option_name": "F", "content": "以上均能获得<br>"}]}, {"answer": "D", "type": "单选", "name": "<p>下面哪个不是线性表?</p>", "options": [{"option_name": "A", "content": "循环链表<br>"}, {"option_name": "B", "content": "队列<br>"}, {"option_name": "C", "content": "栈<br>"}, {"option_name": "D", "content": "关联数组<br>"}, {"option_name": "E", "content": "空字符串数组<br>"}, {"option_name": "F", "content": "双向链表<br>"}]}, {"answer": "B", "type": "单选", "name": "<p>某体校选择校服,每套校服都包括短袖运动衫,长袖运动衫,厚外套,运动长裤和运动短裤组成.每种运动服有个备选方案.老师请了部分学生来挑选自己喜欢的校服.结果发现任意3个学生都至少在一种运动服上选择互不相同,那么老师最多邀请了()名学生参加挑选.</p>", "options": [{"option_name": "A", "content": "7<br>"}, {"option_name": "B", "content": "8<br>"}, {"option_name": "C", "content": "9<br>"}, {"option_name": "D", "content": "10<br>"}, {"option_name": "E", "content": "11<br>"}, {"option_name": "F", "content": "12<br>"}]}, {"answer": "C", "type": "单选", "name": "<p>关于linux的I/O复用接口select和epoll,下列说法错误的是()</p>", "options": [{"option_name": "A", "content": "select调用时会进行线性遍历,epoll采用回调函数机制,不需要线性遍历<br>"}, {"option_name": "B", "content": "select的最大连接数为FD_SETSIZE<br>"}, {"option_name": "C", "content": "select较适合于有大量并发连接,且活跃链接较多的场景<br>"}, {"option_name": "D", "content": "epoll较适用于有大量并发连接，但活跃连接不多的场景<br>"}, {"option_name": "E", "content": "epoll的效率不随FD数目增加而线性下降<br>"}, {"option_name": "F", "content": "epoll通过共享存储实现内核和用户的数据交互<br>"}]}, {"answer": "B", "type": "单选", "name": "<p>下面关于系统调用的描述中,错误的是()</p>", "options": [{"option_name": "A", "content": "系统调用把应用程序的请求传输给系统内核执行<br>"}, {"option_name": "B", "content": "系统调用中被调用的过程运行在\"用户态\"中<br>"}, {"option_name": "C", "content": "利用系统调用能够得到操作系统提供的多种服务<br>"}, {"option_name": "D", "content": "是操作系统提供给编程人员的借口<br>"}, {"option_name": "E", "content": "系统调用给用户屏蔽了设备访问的细节<br>"}, {"option_name": "F", "content": "系统调用保护了一些只能在内核模式执行操作指令<br>"}]}, {"answer": "F", "type": "单选", "name": "<p>在100-999这900个自然数中,若将组成这个数的三个数字认为是三条线段的长度,那么是三条线段组成一个等腰三角形(包括等边)的共有()个.</p>", "options": [{"option_name": "A", "content": "45"}, {"option_name": "B", "content": "91<br>"}, {"option_name": "C", "content": "121<br>"}, {"option_name": "D", "content": "142<br>"}, {"option_name": "E", "content": "156<br>"}, {"option_name": "F", "content": "165<br>"}]}, {"answer": "D", "type": "单选", "name": "<p>以下二叉树的后序遍历结果是()<img alt=\"\" src=\"http://bj.bcebos.com/v1/acmcoder/1943437977930875.png?authorization=bce-auth-v1%2F02fe1db0eea94e8480054b43acd6124f%2F2016-06-09T13%3A09%3A57Z%2F-1%2F%2F47b47c819cdf8c05d9d86ca66f8eaf1e75a7b97ae42f00bba1e21e67c35b949c\" title=\"\"></p>", "options": [{"option_name": "A", "content": "(ABCDEF)<br>"}, {"option_name": "B", "content": "(ABDECF)<br>"}, {"option_name": "C", "content": "(FCEDBA)<br>"}, {"option_name": "D", "content": "(DEBFCA)<br>"}, {"option_name": "E", "content": "(FEDCBA)<br>"}, {"option_name": "F", "content": "<p>(EDBFCA)<br></p>"}]}, {"answer": "A", "type": "单选", "name": "<p>有4副相同的牌,每副牌有4张不同的牌.先从这16张牌中,随机选4张出来.然后,在这4张牌中随机选择一张牌,然后把抽出的一张放回3张中,再随机选择一张牌.与上次选出的牌一样的概率是()</p>", "options": [{"option_name": "A", "content": "1/4<br>"}, {"option_name": "B", "content": "1/3<br>"}, {"option_name": "C", "content": "2/5<br>"}, {"option_name": "D", "content": "1/2<br>"}, {"option_name": "E", "content": "2/3<br>"}, {"option_name": "F", "content": "3/4<br>"}]}, {"answer": "C", "type": "单选", "name": "<p>下面关于一个类的静态成员描述中,不正确的是()</p>", "options": [{"option_name": "A", "content": "静态成员变量可被该类的所有方法访问<br>"}, {"option_name": "B", "content": "该类的静态方法只能访问该类的静态成员函数<br>"}, {"option_name": "C", "content": "该类的静态数据成员变量的值不可修改<br>"}, {"option_name": "D", "content": "子类可以访问父类的静态成员<br>"}, {"option_name": "E", "content": "静态成员无多态特性<br>"}]}, {"answer": "C", "type": "单选", "name": "<p>struct st<br>{<br>&nbsp;&nbsp;&nbsp; int *p;<br>&nbsp;&nbsp;&nbsp; int i;<br>&nbsp;&nbsp;&nbsp; char a;<br>};<br>int sz=sizeof(struct st);<br>如下C程序,在64位处理器上运行后sz的值是什么?</p>", "options": [{"option_name": "A", "content": "24<br>"}, {"option_name": "B", "content": "20<br>"}, {"option_name": "C", "content": "16<br>"}, {"option_name": "D", "content": "14<br>"}, {"option_name": "E", "content": "13<br>"}, {"option_name": "F", "content": "12<br>"}]}, {"answer": "D", "type": "单选", "name": "<p>给定的一个长度为N的字符串str,查找长度为P(P&lt;N)的字符串在str中的出现次数.下面的说法正确的是()</p>", "options": [{"option_name": "A", "content": "不存在比最坏时间复杂度O(NP)好的算法<br>"}, {"option_name": "B", "content": "不存在比最坏时间复杂度O(N^2)好的算法<br>"}, {"option_name": "C", "content": "不存在比最坏时间复杂度O(P^2)好的算法<br>"}, {"option_name": "D", "content": "存在最坏时间复杂度为O(N+P)的算法<br>"}, {"option_name": "E", "content": "存在最坏时间复杂度为O(log(N+P))的算法<br>"}, {"option_name": "F", "content": "以上都不对<br>"}]}, {"answer": "B", "type": "单选", "name": "<p>下面的哪种排序算法在算复杂度平均不是O(nlogn)的?</p>", "options": [{"option_name": "A", "content": "快速排序<br>"}, {"option_name": "B", "content": "桶排序<br>"}, {"option_name": "C", "content": "合并排序<br>"}, {"option_name": "D", "content": "二叉树排序树排序<br>"}, {"option_name": "E", "content": "堆排序<br>"}]}, {"answer": "D", "type": "单选", "name": "对N个数进行排序,在各自最优条件下以下算法复杂度最低的是( &nbsp; )", "options": [{"option_name": "A", "content": "快速排序<br>"}, {"option_name": "B", "content": "堆排序"}, {"option_name": "C", "content": "冒泡排序"}, {"option_name": "D", "content": "插入排序"}, {"option_name": "E", "content": "选择排序"}, {"option_name": "F", "content": "归并排序"}]}, {"answer": "F", "type": "单选", "name": "<p>在自由交换的情况下,只考虑偏好,小张用自己的小刀换了小王的橡皮.关于这个交换以下说法错误的是:</p>", "options": [{"option_name": "A", "content": "小张觉得橡皮比小刀更好<br>"}, {"option_name": "B", "content": "小王觉得小刀比橡皮更好<br>"}, {"option_name": "C", "content": "小张和小王总的财富里没有发生变化<br>"}, {"option_name": "D", "content": "小张和小王的效用值增加了<br>"}, {"option_name": "E", "content": "如果把小王换成小吴，那么这个交换可能就不会发生<br>"}, {"option_name": "F", "content": "小刀和橡皮等值"}]}, {"answer": "B", "type": "单选", "name": "<p>一个黑盒子里有若干红球和黑球,随机取出一个球是红球的概率是p.现在从黑盒子中拿出等量的红球和黑球后,随机取出一个球是红球的概率是q,如果p&lt;q,那么以下说法正确的是()</p>", "options": [{"option_name": "A", "content": "最初红球的个数小于黑球的个数"}, {"option_name": "B", "content": "最初红球的个数大于黑球的个数"}, {"option_name": "C", "content": "最初红球的个数是黑球的的2倍"}, {"option_name": "D", "content": "最初红球的个数是黑球的1/2"}, {"option_name": "E", "content": "无法判断最初红球和黑球谁多谁少"}]}, {"answer": "A", "type": "单选", "name": "<pre class=\"brush:cpp;toolbar:false\">main()\r\n{\r\n&nbsp;&nbsp;&nbsp;&nbsp;char*a[]={\"work\",\"at\",\"alibaba\"};\r\n&nbsp;&nbsp;&nbsp;&nbsp;char**pa=a;\r\n&nbsp;&nbsp;&nbsp;&nbsp;pa++;\r\n&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%s\",*pa);\r\n}</pre><p>下列程序的执行结果是()<br></p>", "options": [{"option_name": "A", "content": "at"}, {"option_name": "B", "content": "atalibaba"}, {"option_name": "C", "content": "ork"}, {"option_name": "D", "content": "orkatalibaba"}, {"option_name": "E", "content": "编译错误"}, {"option_name": "F", "content": "运行溢出"}]}, {"answer": "A", "type": "单选", "name": "<p>甲乙两个一样大小的杯子各自分别装着小于一半容积的水和酒精.现将甲杯子里的一部分水倒入乙杯子;之后将乙杯子的混合液倒入一些到甲杯子,此时甲杯子的液体恢复到最初的状态.假定水和酒精混合之后的体积等于混合之前的体积之和.那么以下说法正确的是()</p>", "options": [{"option_name": "A", "content": "甲杯子里的酒精体积等于乙杯子里的水的体积<br>"}, {"option_name": "B", "content": "甲杯子里的酒精的体积等于乙杯子里的酒精的体积<br>"}, {"option_name": "C", "content": "甲杯子里的水的体积等于乙杯子里的酒精的体积<br>"}, {"option_name": "D", "content": "甲杯子里的水的体积等于乙杯子里的水的体积<br>"}, {"option_name": "E", "content": "甲杯子里的液体高于乙杯子里的液位<br>"}, {"option_name": "F", "content": "<p>以上都不对<br></p>"}]}, {"answer": "D", "type": "单选", "name": "<p>关于c++的inline关键字,以下说法正确的是()<br></p>", "options": [{"option_name": "A", "content": "使用inline关键字的函数会被编译器在调用处展开"}, {"option_name": "B", "content": "头文件中可以包含inline函数的声明"}, {"option_name": "C", "content": "可以在同一个项目的不同源文件内定义函数名相同但实现不同的inline函数"}, {"option_name": "D", "content": "定义在Class声明内的成员函数默认是inline函数"}, {"option_name": "E", "content": "优先使用Class声明内定义的inline函数<br>"}, {"option_name": "F", "content": "优先使用Class实现的内inline函数的实现"}]}, {"answer": "C", "type": "单选", "name": "<p>#include &lt;iostream&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br>#include &lt;vector&gt;<br>using namespace std;<br>int main(void)<br>{<br>&nbsp;&nbsp;&nbsp; vector&lt;int&gt;array;<br>&nbsp;&nbsp;&nbsp; array.push_back(100);<br>&nbsp;&nbsp;&nbsp; array.push_back(300);<br>&nbsp;&nbsp;&nbsp; array.push_back(300);<br>&nbsp;&nbsp;&nbsp; array.push_back(300);<br>&nbsp;&nbsp;&nbsp; array.push_back(300);<br>&nbsp;&nbsp;&nbsp; array.push_back(500);<br>&nbsp;&nbsp;&nbsp; vector&lt;int&gt;::iterator itor;<br>&nbsp;&nbsp;&nbsp; for(itor=array.begin();itor!=array.end();itor++)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(*itor==300)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itor=array.erase(itor);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; for(itor=array.begin();itor!=array.end();itor++)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout&lt;&lt;*itor&lt;&lt;\"\";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; return 0;<br>}<br>下面这个代码输出的是()</p>", "options": [{"option_name": "A", "content": "100 300 300 300  300 500"}, {"option_name": "B", "content": "100 300 300 300 500<br>"}, {"option_name": "C", "content": "100 300 300 500<br>"}, {"option_name": "D", "content": "100 300 500<br>"}, {"option_name": "E", "content": "100 500<br>"}, {"option_name": "F", "content": "程序错误"}]}, {"answer": "B", "type": "单选", "name": "<p>某创业团队的一个很大的办公室(障碍和遮挡可以忽略)里有一个WIFI源,有1个工位由于距离WIFI源太远而接收不到信号.为了提高该工位的联网质量，准备在工位和WIFI信号源之间安装一个无线AP(相当于中继的,可以中转该工位上的计算机和WIFI之间的信号).只考虑从WIFI发出的信号，如果AP离WIFI源太近，就起不到中继的作用,如果AP离工位太远则可能连不上WIFI.因此AP有一个最佳的安装位置,那么关于AP最佳安装位置的说法正确的是()</p>", "options": [{"option_name": "A", "content": "如果WIFI源功率越大,那么AP最佳安装位置越靠近WIFI源<br>"}, {"option_name": "B", "content": "如果WiFi源功率越大,那么AP最佳的安装位置越靠近工位<br>"}, {"option_name": "C", "content": "WIFI源功率和AP最佳安装位置无关.<br>"}, {"option_name": "D", "content": "AP最佳安装位置在工位和WIFI信号源连线之外<br>"}, {"option_name": "E", "content": "AP最佳安装位置在工位和WIFI信号源连线中点<br>"}, {"option_name": "F", "content": "以上说法都不对<br>"}]}, {"answer": "D", "type": "单选", "name": "<p>7的2014次方这个整数的十位数字数是()</p>", "options": [{"option_name": "A", "content": "0"}, {"option_name": "B", "content": "1<br>"}, {"option_name": "C", "content": "3<br>"}, {"option_name": "D", "content": "4<br>"}, {"option_name": "E", "content": "5<br>"}, {"option_name": "F", "content": "7<br>"}]}, {"answer": "D", "type": "单选", "name": "<p>在TCP/IP建立连接过程中,客户端和服务器端的状态转移说法错误的是?</p>", "options": [{"option_name": "A", "content": "经历SYN_RECV状态<br>"}, {"option_name": "B", "content": "经历SYN_SEND状态<br>"}, {"option_name": "C", "content": "经历ESTABLISHED状态<br>"}, {"option_name": "D", "content": "经历TIME_WAIT状态<br>"}, {"option_name": "E", "content": "服务器在收到syn包时将加入半连接队列<br>"}, {"option_name": "F", "content": "<p>服务器接受到客户端的ack包后将从半连接队列删除<br></p>"}]}, {"answer": "B", "type": "单选", "name": "<p>有100个金币，分给10个人.第一个金币等概率地分给10个人之一.之后的每一个金币分配给第K个人的概率正比于这个人已经持有的金币数+1.在这样的分配机制下，关于每个人最终的金币个数的分布的说法错误的是()</p>", "options": [{"option_name": "A", "content": "每个人得到的金币的个数的期望是相等的<br>"}, {"option_name": "B", "content": "每个人的金币个数接近均匀分布<br>"}, {"option_name": "C", "content": "第一个金币给哪个人,哪个人的最终金币个数的期望就会更大<br>"}, {"option_name": "D", "content": "在中间的某个阶段金币个数越多的人，未来获得金币的可能性越大<br>"}, {"option_name": "E", "content": "以上说法都是正确的<br>"}, {"option_name": "F", "content": "以上说法都是不正确的<br>"}]}, {"answer": "E", "type": "单选", "name": "<p>假设在n进制下,下面的等式成立,n值是()240*12=2880</p>", "options": [{"option_name": "A", "content": "19<br>"}, {"option_name": "B", "content": "18<br>"}, {"option_name": "C", "content": "17<br>"}, {"option_name": "D", "content": "16<br>"}, {"option_name": "E", "content": "15<br>"}, {"option_name": "F", "content": "以上都不对<br>"}]}], "company": "阿里巴巴", "name": "阿里巴巴2016 实习生招聘（一）", "id": "77"}