{"url": "http://exercise.acmcoder.com/comp_test?paperId=169", "content": [{"answer": "ABC", "type": "不定项选择", "name": "<p>下面有关 JAVA 异常类的描述,说法正确的有？</p>", "options": [{"option_name": "A", "content": "异常的继承结构:基类为 Throwable，其中Error 和 Exception 继承 Throwable，而RuntimeException 和 IOException 等继承 Exception"}, {"option_name": "B", "content": "非 RuntimeException 一般是外部错误,其需要被 try{}catch 语句块所捕获，或者用throws子句声明抛出"}, {"option_name": "C", "content": "Error 类体系描述了 Java 运行系统中的内部错误以及资源耗尽的情形,Error 通常不需要捕捉"}, {"option_name": "D", "content": "<p>RuntimeException 体系包括错误的类型转换、数组越界访问和试图访问空指针等等,必须被 try{}catch 语句块所捕获</p>"}]}, {"answer": "C", "type": "单选", "name": "<p>关于异常处理机制的叙述正确的是？</p>", "options": [{"option_name": "A", "content": "catch部分捕捉到异常情况时，才会执行finally部分"}, {"option_name": "B", "content": "当try区段的程序发生异常时，才会执行finally部分"}, {"option_name": "C", "content": "当try区段不论程序是否发生错误及捕捉到异常情况，都会执行finally部分"}, {"option_name": "D", "content": "以上都不对"}]}, {"answer": "C", "type": "单选", "name": "<p>下列说法正确的有？</p>", "options": [{"option_name": "A", "content": "class中的constructor不可省略"}, {"option_name": "B", "content": "constructor必须与class同名，但方法不能与class同名"}, {"option_name": "C", "content": "constructor在一个对象被new时执行"}, {"option_name": "D", "content": "<p> 一个class只能定义一个constructor</p>"}]}, {"answer": "C", "type": "单选", "name": "<p>执行下列代码的输出结果是？<br></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Demo{\r\n　public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[]){\r\n　　　int&nbsp;num&nbsp;=&nbsp;10;\r\n　　　System.out.println(test(num));\r\n}\r\npublic&nbsp;static&nbsp;int&nbsp;test(int&nbsp;b){\r\n　　　try\r\n　　　{\r\n　　　　b&nbsp;+=&nbsp;10;\r\n　　　　return&nbsp;b;\r\n　　　}\r\n　　　catch(RuntimeException&nbsp;e)\r\n　　　{\r\n　　　}\r\n　　　catch(Exception&nbsp;e2)\r\n　　　{\r\n　　　}\r\n　　　finally\r\n　　　{\r\n　　　　b&nbsp;+=&nbsp;10;\r\n　　　　return&nbsp;b;\r\n　　　}\r\n　　}\r\n}</pre>", "options": [{"option_name": "A", "content": "10"}, {"option_name": "B", "content": "20"}, {"option_name": "C", "content": "30"}, {"option_name": "D", "content": "40"}]}, {"answer": "C", "type": "单选", "name": "<p>this代表了( &nbsp; &nbsp;)的对象引用,super表示的是当前对象的( &nbsp; &nbsp;)对象?</p>", "options": [{"option_name": "A", "content": "当前类 当前类"}, {"option_name": "B", "content": "当前类的父类 当前类"}, {"option_name": "C", "content": "当前类 当前类的父类"}, {"option_name": "D", "content": "以上都不正确"}]}, {"answer": "D", "type": "单选", "name": "<p>下面代码的输出结果是什么？<br></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;ZeroTest&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;100&nbsp;/&nbsp;0;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(i);\r\n&nbsp;&nbsp;}catch(Exception&nbsp;e){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(1);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();\r\n&nbsp;&nbsp;}finally{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(2);\r\n&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(3);\r\n&nbsp;}\r\n&nbsp;}</pre>", "options": [{"option_name": "A", "content": "3"}, {"option_name": "B", "content": "123"}, {"option_name": "C", "content": "1"}, {"option_name": "D", "content": "12"}]}, {"answer": "C", "type": "单选", "name": "<p>关于Java语言的内存回收机制，下列选项中最正确的一项是</p>", "options": [{"option_name": "A", "content": "Java程序要求用户必须手工创建一个线程来释放内存"}, {"option_name": "B", "content": "Java程序允许用户使用指针来释放内存Java程序允许用户使用指针来释放内存"}, {"option_name": "C", "content": "内存回收线程负责释放无用内存"}, {"option_name": "D", "content": "<p>内存回收线程不能释放内存对象</p>"}]}, {"answer": "C", "type": "单选", "name": "<p>以下程序执行的结果是（ &nbsp; &nbsp;）<br></p><pre class=\"brush:java;toolbar:false\">class&nbsp;X{\r\n&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;y=new&nbsp;Y();\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;X(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(\"X\");\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}\r\nclass&nbsp;Y{\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Y(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(\"Y\");\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}\r\npublic&nbsp;class&nbsp;Z&nbsp;extends&nbsp;X{\r\n&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;y=new&nbsp;Y();\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Z(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(\"Z\");\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Z();\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre>", "options": [{"option_name": "A", "content": "ZYXX"}, {"option_name": "B", "content": "ZYXY"}, {"option_name": "C", "content": "YXYZ"}, {"option_name": "D", "content": "XYZX"}]}, {"answer": "D", "type": "单选", "name": "<p>在如下所示的类Test中，共有（ &nbsp; &nbsp;）个构造方法。<br></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Test\r\n{\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;x;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Test()\r\n&nbsp;&nbsp;&nbsp;&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;35;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;Test(double&nbsp;f)\r\n&nbsp;&nbsp;&nbsp;&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.x&nbsp;=&nbsp;(int)f;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Test(double&nbsp;f)\r\n&nbsp;&nbsp;&nbsp;&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.x&nbsp;=&nbsp;(int)f;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Test(String&nbsp;s)&nbsp;{}\r\n}</pre>", "options": [{"option_name": "A", "content": "0"}, {"option_name": "B", "content": "1"}, {"option_name": "C", "content": "2"}, {"option_name": "D", "content": "3"}]}, {"answer": "C", "type": "单选", "name": "<p>阅读下面Java程序代码：<br></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Test\r\n{\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;x;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])\r\n&nbsp;&nbsp;&nbsp;&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.&nbsp;out.&nbsp;println(\"Value&nbsp;is\"&nbsp;+&nbsp;x);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p>对于上面这段代码，以下说法正确的是：</p>", "options": [{"option_name": "A", "content": "程序会打出 Value is 0"}, {"option_name": "B", "content": "程序会抛出 NullPointerException"}, {"option_name": "C", "content": "非静态变量不能够被静态方法引用"}, {"option_name": "D", "content": "编译器会抛出possible reference before assignment的错误"}]}, {"answer": "B", "type": "单选", "name": "<p>下面有关final, finally, finalize的区别描述错误的是？</p>", "options": [{"option_name": "A", "content": "如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承"}, {"option_name": "B", "content": "如果一个方法被声明为final，可以被覆盖"}, {"option_name": "C", "content": "finally在异常处理时提供 finally 块来执行任何清除操作"}, {"option_name": "D", "content": "Java使用 finalize() 方法在垃圾收集器象从内存中清除出去之前做必要的清理工作"}]}, {"answer": "A", "type": "单选", "name": "<p>在JAVA中，下面关于String类和StringBuffer类的描述正确的是那一个？</p>", "options": [{"option_name": "A", "content": "StringBuffer类的对象调用toString（）方法将转换为String类型"}, {"option_name": "B", "content": "两个类都有append（）方法"}, {"option_name": "C", "content": "可以直接将字符串“test”赋值给声明的Stirng类和StringBuffer类的变量"}, {"option_name": "D", "content": "个类的实例的值都能够被改变"}]}, {"answer": "ABC", "type": "不定项选择", "name": "<p>下列说法错误的有（ &nbsp; &nbsp;）</p>", "options": [{"option_name": "A", "content": "Java面向对象语言容许单独的过程与函数存在"}, {"option_name": "B", "content": "Java面向对象语言容许单独的方法存在"}, {"option_name": "C", "content": "Java语言中的方法属于类中的成员（member）"}, {"option_name": "D", "content": "<p>Java语言中的方法必定隶属于某一类（对象），调用方法与过程或函数相同</p>"}]}, {"answer": "ADE", "type": "不定项选择", "name": "<p>以下哪些类是线程安全的？</p>", "options": [{"option_name": "A", "content": "Vector"}, {"option_name": "B", "content": "HashMap"}, {"option_name": "C", "content": "ArrayList"}, {"option_name": "D", "content": "StringBuffer"}, {"option_name": "E", "content": "<p>Properties</p>"}]}, {"answer": "C", "type": "单选", "name": "<p>子类A继承父类B, A a = new A(); 则父类B构造函数、父类B静态代码块、父类B非静态代码块、子类A构造函数、子类A静态代码块、子类A非静态代码块 执行的先后顺序是？</p>", "options": [{"option_name": "A", "content": "父类Ｂ静态代码块->父类Ｂ构造函数->子类Ａ静态代码块->父类Ｂ非静态代码块->子类Ａ构造函数->子类Ａ非静态代码块"}, {"option_name": "B", "content": "父类Ｂ静态代码块->父类Ｂ构造函数->父类Ｂ非静态代码块->子类Ａ静态代码块->子类Ａ构造函数->子类Ａ非静态代码块"}, {"option_name": "C", "content": "父类Ｂ静态代码块->子类Ａ静态代码块->父类Ｂ非静态代码块->父类Ｂ构造函数->子类Ａ非静态代码块->子类Ａ构造函数"}, {"option_name": "D", "content": "<p>父类Ｂ构造函数->父类Ｂ静态代码块->父类Ｂ非静态代码块->子类Ａ静态代码块->子类Ａ构造函数->子类Ａ非静态代码块</p>"}]}, {"answer": "ACD", "type": "不定项选择", "name": "<p>忽略内部接口的情况，不能用来修饰interface的有？</p>", "options": [{"option_name": "A", "content": "private"}, {"option_name": "B", "content": "public"}, {"option_name": "C", "content": "protected"}, {"option_name": "D", "content": "static"}]}, {"answer": "C", "type": "单选", "name": "<p>下列Java代码中的变量a、b、c分别在内存的____存储区存放。<br></p><pre class=\"brush:java;toolbar:false\">class&nbsp;A&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;a&nbsp;=&nbsp;“aa”;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;methodB()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;b&nbsp;=&nbsp;“bb”;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;String&nbsp;c&nbsp;=&nbsp;“cc”;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre>", "options": [{"option_name": "A", "content": "堆区、堆区、堆区"}, {"option_name": "B", "content": "堆区、栈区、堆区"}, {"option_name": "C", "content": "堆区、栈区、栈区"}, {"option_name": "D", "content": "<p>堆区、堆区、栈区</p>"}]}, {"answer": "B", "type": "单选", "name": "<p>下面有关servlet service描述错误的是？</p>", "options": [{"option_name": "A", "content": "不管是post还是get方法提交过来的连接，都会在service中处理"}, {"option_name": "B", "content": "doGet/doPost 则是在 javax.servlet.GenericServlet 中实现的"}, {"option_name": "C", "content": "service()是在javax.servlet.Servlet接口中定义的"}, {"option_name": "D", "content": "service判断请求类型，决定是调用doGet还是doPost方法"}]}, {"answer": "D", "type": "单选", "name": "<p>在Java中，以下关于方法重载和方法重写描述正确的是？</p>", "options": [{"option_name": "A", "content": "方法重载和方法的重写实现的功能相同"}, {"option_name": "B", "content": "方法重载出现在父子关系中，方法重写是在同一类中"}, {"option_name": "C", "content": "方法重载的返回值类型必须一致，参数项必须不同"}, {"option_name": "D", "content": "方法重写的返回值类型必须相同或相容。（或是其子类）"}]}, {"answer": "B", "type": "单选", "name": "<p>已知表达式int m[]={0，1，2，3，4，5，6}；下面哪个表达式的值与数组下标量最大值相等？</p>", "options": [{"option_name": "A", "content": "m.length()"}, {"option_name": "B", "content": "m. length-1"}, {"option_name": "C", "content": "m. length()+1"}, {"option_name": "D", "content": "m. length+1"}]}, {"answer": "B", "type": "单选", "name": "<p>下列关于Java并发的说法中正确的是？</p>", "options": [{"option_name": "A", "content": "CopyOnWriteArrayList适用于写多读少的并发场景"}, {"option_name": "B", "content": "ReadWriteLock适用于读多写少的并发场景"}, {"option_name": "C", "content": "ConcurrentHashMap的写操作不需要加锁，读操作需要加锁"}, {"option_name": "D", "content": "<p>只要在定义int类型的成员变量i的时候加上volatile关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了</p>"}]}, {"answer": "ACD", "type": "不定项选择", "name": "<p>java中关于继承的描述正确的是？</p>", "options": [{"option_name": "A", "content": "一个子类只能继承一个父类"}, {"option_name": "B", "content": "子类可以继承父类的构造方法"}, {"option_name": "C", "content": "继承具有传递性"}, {"option_name": "D", "content": "父类一般具有通用性，子类更具体"}]}, {"answer": "A", "type": "单选", "name": "<p>阅读下面程序：<br></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Test{\r\n&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;cnt&nbsp;=&nbsp;6;\r\n&nbsp;&nbsp;&nbsp;&nbsp;static{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt&nbsp;+=&nbsp;9;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\npublic&nbsp;static&nbsp;void&nbsp;main(string[]&nbsp;args）{\r\n&nbsp;&nbsp;&nbsp;&nbsp;System.out.println（“cnt&nbsp;=”&nbsp;+&nbsp;cnt);\r\n}\r\nstatic{\r\n&nbsp;&nbsp;&nbsp;&nbsp;Cnt&nbsp;/=3;\r\n&nbsp;&nbsp;&nbsp;&nbsp;};\r\n}</pre><p>Cnt的值是（ &nbsp; &nbsp;）</p>", "options": [{"option_name": "A", "content": "Cnt=5"}, {"option_name": "B", "content": "Cnt=2"}, {"option_name": "C", "content": "Cnt=3"}, {"option_name": "D", "content": "Cnt=6"}]}, {"answer": "C", "type": "单选", "name": "<p>下面有关java classloader说法错误的是?</p>", "options": [{"option_name": "A", "content": "Java默认提供的三个ClassLoader是BootStrap ClassLoader，Extension ClassLoader，App ClassLoader"}, {"option_name": "B", "content": "ClassLoader使用的是双亲委托模型来搜索类的"}, {"option_name": "C", "content": "JVM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关"}, {"option_name": "D", "content": "ClassLoader就是用来动态加载class文件到内存当中用的"}]}, {"answer": "CD", "type": "不定项选择", "name": "<p>线程安全的map在JDK 1.5及其更高版本环境 有哪几种方法可以实现?</p>", "options": [{"option_name": "A", "content": "Map map = new HashMap()"}, {"option_name": "B", "content": "Map map = new TreeMap()"}, {"option_name": "C", "content": "Map map = new ConcurrentHashMap()"}, {"option_name": "D", "content": "Map map = Collections.synchronizedMap(new HashMap())"}]}, {"answer": "G", "type": "单选", "name": "<p>阅读下面Java程序代码：<br></p><pre class=\"brush:java;toolbar:false\">Integer&nbsp;i&nbsp;=&nbsp;42;\r\nLong&nbsp;l&nbsp;=&nbsp;42l;\r\nDouble&nbsp;d&nbsp;=&nbsp;42.0;</pre><p>下面为true的是（ &nbsp; &nbsp;）</p>", "options": [{"option_name": "A", "content": "(i == l)"}, {"option_name": "B", "content": "(i == d)"}, {"option_name": "C", "content": "(l == d)"}, {"option_name": "D", "content": "i.equals(d)"}, {"option_name": "E", "content": "d.equals(l)"}, {"option_name": "F", "content": "i.equals(l)"}, {"option_name": "G", "content": "<p>l.equals(42L)</p>"}]}, {"answer": "B", "type": "单选", "name": "<p>下面有关java object默认的基本方法，说法错误的是？</p>", "options": [{"option_name": "A", "content": "equals(Object obj) 指示某个其他对象是否与此对象相等"}, {"option_name": "B", "content": "copy() 创建并返回此对象的一个副本"}, {"option_name": "C", "content": "wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法"}, {"option_name": "D", "content": "<p>toString() 返回该对象的字符串表示</p>"}]}, {"answer": "C", "type": "单选", "name": "<p>下面有关JVM内存，说法错误的是？</p>", "options": [{"option_name": "A", "content": "程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的"}, {"option_name": "B", "content": "Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的"}, {"option_name": "C", "content": "方法区用于存储JVM加载的类信息、常量、静态变量、即使编译器编译后的代码等数据，是线程隔离的"}, {"option_name": "D", "content": "<p>原则上讲，所有的对象都在堆区上分配内存，是线程之间共享</p>"}]}, {"answer": "C", "type": "单选", "name": "<p>蔺相如，司马相如；魏无忌，长孙无忌。下列哪一组对应关系与此类似？</p>", "options": [{"option_name": "A", "content": "PHP，Python"}, {"option_name": "B", "content": "JSP，servlet"}, {"option_name": "C", "content": "Java，Javascript"}, {"option_name": "D", "content": "C，C++"}]}, {"answer": "CD", "type": "不定项选择", "name": "<p>有关线程的叙述正确的是？</p>", "options": [{"option_name": "A", "content": "可以获得对任何对象的互斥锁定"}, {"option_name": "B", "content": "通过继承Thread类或实现Runnable接口，可以获得对类中方法的互斥锁定"}, {"option_name": "C", "content": "线程通过调用对象的synchronized方法可获得对象的互斥锁定"}, {"option_name": "D", "content": "<p>线程调度算法是平台独立的</p>"}]}, {"answer": "B", "type": "单选", "name": "<p>下列程序的运行结果？<br></p><pre class=\"brush:java;toolbar:false\">public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;{\r\n&nbsp;&nbsp;&nbsp;Thread&nbsp;t&nbsp;=&nbsp;new&nbsp;Thread()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;run()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pong();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.run();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(\"ping\");\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;void&nbsp;pong()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(\"pong\");\r\n}</pre>", "options": [{"option_name": "A", "content": "pingpong"}, {"option_name": "B", "content": "pongping"}, {"option_name": "C", "content": "pingpong和pongping都有可能"}, {"option_name": "D", "content": "<p>都不输出</p>"}]}, {"answer": "A", "type": "单选", "name": "<p>volatile关键字的说法错误的是？</p>", "options": [{"option_name": "A", "content": "能保证线程安全"}, {"option_name": "B", "content": "volatile关键字用在多线程同步中，可保证读取的可见性"}, {"option_name": "C", "content": "JVM保证从主内存加载到线程工作内存的值是最新的"}, {"option_name": "D", "content": "volatile能禁止进行指令重排序"}]}, {"answer": "B", "type": "单选", "name": "<p>JAVA语言的下面几种数组复制方法中，哪个效率最高？</p>", "options": [{"option_name": "A", "content": "for循环逐一复制"}, {"option_name": "B", "content": "System.arraycopy"}, {"option_name": "C", "content": "System.copyof"}, {"option_name": "D", "content": "使用clone方法"}]}, {"answer": "BCE", "type": "不定项选择", "name": "<p>实现或继承了Collection接口的是</p>", "options": [{"option_name": "A", "content": "map"}, {"option_name": "B", "content": "List"}, {"option_name": "C", "content": "vector"}, {"option_name": "D", "content": "Iterator"}, {"option_name": "E", "content": "<p>Set</p>"}]}, {"answer": "B", "type": "单选", "name": "<p>下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换：（B）</p><p>数据类型：byte[] src, dst;</p>", "options": [{"option_name": "A", "content": "dst=String.fromBytes(src，\"GBK\").getBytes(\"UTF-8\")"}, {"option_name": "B", "content": "dst=new String(src，\"GBK\").getBytes(\"UTF-8\")"}, {"option_name": "C", "content": "dst=new String(\"GBK\"，src).getBytes()"}, {"option_name": "D", "content": "dst=String.encode(String.decode(src，\"GBK\"))，\"UTF-8\" )"}]}, {"answer": "D", "type": "单选", "name": "<p>对于JVM内存配置参数：</p><p>-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3</p><p>其最小内存值和Survivor区总大小分别是</p>", "options": [{"option_name": "A", "content": "5120m，1024m"}, {"option_name": "B", "content": "5120m，2048m"}, {"option_name": "C", "content": "10240m，1024m"}, {"option_name": "D", "content": "10240m，2048m"}]}, {"answer": "CD", "type": "不定项选择", "name": "<p>下列有关java构造跟使用叙述正确的是</p>", "options": [{"option_name": "A", "content": "构造器的返回值为vold类型"}, {"option_name": "B", "content": "如果一个源文件中有多个类，那么构造器必须与公共类同名"}, {"option_name": "C", "content": "构造器可以有0个，1个或一个以上的参数"}, {"option_name": "D", "content": "每个类可以有一个以上的构造器"}]}, {"answer": "A", "type": "单选", "name": "<p>对于一个已经不被任何变量引用的对象，当垃圾回收器准备回收该对象所占用的内存时，将自动调用该对象的哪个方法？</p>", "options": [{"option_name": "A", "content": "finalize"}, {"option_name": "B", "content": "notify"}, {"option_name": "C", "content": "notifyAll"}, {"option_name": "D", "content": "hashCode"}]}, {"answer": "D", "type": "单选", "name": "<p>下列关于java 中的 wait( &nbsp; &nbsp;)方法和 sleep( &nbsp; &nbsp;)方法的区别描述错误的是？</p>", "options": [{"option_name": "A", "content": "wait()方法属于Object类，二sleep()属于Thread类"}, {"option_name": "B", "content": "调用wait()方法的时候，线程会放弃对象锁"}, {"option_name": "C", "content": "调用sleep()方法的过程中，线程不会释放对象锁"}, {"option_name": "D", "content": "<p>sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程</p>"}]}, {"answer": "C", "type": "单选", "name": "<p>&nbsp;有如下4条语句：<br></p><pre class=\"brush:java;toolbar:false\">Integer&nbsp;i01&nbsp;=&nbsp;59;\r\nint&nbsp;i02&nbsp;=&nbsp;59;\r\nInteger&nbsp;i03&nbsp;=&nbsp;Integer.valueOf(59);\r\nInteger&nbsp;i04&nbsp;=&nbsp;new&nbsp;Integer(59);</pre><p>以下输出结果为false的是？</p>", "options": [{"option_name": "A", "content": "System.out.println(i01==i02);"}, {"option_name": "B", "content": "System.out.println(i01==i03);"}, {"option_name": "C", "content": "System.out.println(i03==i04);"}, {"option_name": "D", "content": "System.out.println(i02==i04);"}]}], "company": "顺丰科技", "name": "顺丰科技2016 内部Java基础测试", "id": "169"}