{"year": "2016", "url": "http://exercise.acmcoder.com/comp_test?paperId=72", "content": [{"answer": "A", "type": "单选", "name": "<p>以下代码输出的是：<br></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;SendValue{\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;str=\"6\";\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SendValue&nbsp;sv=new&nbsp;SendValue();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sv.change(sv.str);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(sv.str);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;change(String&nbsp;str)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str=\"10\";\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre>", "options": [{"option_name": "A", "content": "6"}, {"option_name": "B", "content": "10"}, {"option_name": "C", "content": "都不对"}, {"option_name": "D", "content": "16"}]}, {"answer": "B", "type": "单选", "name": "<p>接口的作用是;</p>", "options": [{"option_name": "A", "content": "减小堆大小"}, {"option_name": "B", "content": "契约式设计以封装实现"}, {"option_name": "C", "content": "实现抽象工厂模式"}, {"option_name": "D", "content": "使抽象类具化"}]}, {"answer": "B", "type": "单选", "name": "<p>哪个变量用来指定一个远程X应用程序将输出放到哪个X server上</p>", "options": [{"option_name": "A", "content": "TERM"}, {"option_name": "B", "content": "DISPLAY"}, {"option_name": "C", "content": "ECHO"}, {"option_name": "D", "content": "OUTPUT"}]}, {"answer": "C", "type": "单选", "name": "<p>instanceof运算符能够用来判断一个对象是否为:</p>", "options": [{"option_name": "A", "content": "一个类的实例"}, {"option_name": "B", "content": "一个实现指定接口的类的实例"}, {"option_name": "C", "content": "全部正确"}, {"option_name": "D", "content": "一个子类的实例"}]}, {"answer": "B", "type": "单选", "name": "<p>有以下类定义：<br></p><pre class=\"brush:java;toolbar:false\">abstract&nbsp;class&nbsp;Animal{\r\n&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;void&nbsp;say();\r\n}\r\npublic&nbsp;class&nbsp;Cat&nbsp;extends&nbsp;Animal{\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Cat(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.printf(\"I&nbsp;am&nbsp;a&nbsp;cat\");\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cat&nbsp;cat=new&nbsp;Cat();\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p>运行后：</p>", "options": [{"option_name": "A", "content": "I am a cat"}, {"option_name": "B", "content": "Animal能编译，Cat不能编译"}, {"option_name": "C", "content": "Animal不能编译，Cat能编译"}, {"option_name": "D", "content": "编译能通过，但是没有输出结果"}]}, {"answer": "A", "type": "单选", "name": "<p>在重新启动Linux系统的同时把内存中的信息写入硬盘，应使用（）命令实现</p>", "options": [{"option_name": "A", "content": "#shutdown -r now"}, {"option_name": "B", "content": "#halt"}, {"option_name": "C", "content": "#reboot"}, {"option_name": "D", "content": "#init3"}]}, {"answer": "A", "type": "单选", "name": "<p>以下代码在编译和运行过程中会出现什么情况</p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;TestDemo{\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;count;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TestDemo&nbsp;test=new&nbsp;TestDemo(88);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(test.count);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TestDemo(int&nbsp;a)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count=a;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p>&nbsp;</p>", "options": [{"option_name": "A", "content": "编译运行通过，输出结果是88"}, {"option_name": "B", "content": "编译时错误，count变量定义的是私有变量"}, {"option_name": "C", "content": "编译时错误，System.out.println方法被调用时test没有被初始化"}, {"option_name": "D", "content": "编译和执行时没有输出结果"}]}, {"answer": "A", "type": "单选", "name": "<p>实现单例模式的类具有?</p>", "options": [{"option_name": "A", "content": "没有公有构造方法，一个公有静态工厂方法，和一个静态实例变量"}, {"option_name": "B", "content": "没有公有构造方法，有一个私有静态工厂方法，和一个静态实例变量"}, {"option_name": "C", "content": "有公有构造方法，没有静态工厂方法和静态实例变量"}, {"option_name": "D", "content": "没有公有构造方法，没有公有静态工厂方法，也没有静态实例变量"}]}, {"answer": "D", "type": "单选", "name": "<p>如果一个方法或变量是\"private\"访问级别，那么它的访问范围是:</p>", "options": [{"option_name": "A", "content": "在当前类，或者子类中"}, {"option_name": "B", "content": "在当前类或者它的父类中"}, {"option_name": "C", "content": "在当前类，或者它所有的父类中"}, {"option_name": "D", "content": "在当前类中"}]}, {"answer": "C", "type": "单选", "name": "<p>类Test1定义如下:<br></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Test1{//1\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;float&nbsp;aMethod(float&nbsp;a,float&nbsp;b){}//2&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;//3\r\n}//4</pre><p>将以下哪种方法插入行3是不合法的。</p>", "options": [{"option_name": "A", "content": "public int aMethod(int a,int b){}"}, {"option_name": "B", "content": "private float aMethod(int a,int b,int c){}"}, {"option_name": "C", "content": "public float aMethod(float a,float b){}"}, {"option_name": "D", "content": "public float aMethod(float a,float b,float c){}"}]}, {"answer": "B", "type": "单选", "name": "<p>给定代码：<br></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;SwitchTest{//1\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{//2\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"value=\"+switchit(4));//3\r\n&nbsp;&nbsp;&nbsp;&nbsp;}//4\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;int&nbsp;switchit(int&nbsp;x)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j=1;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(x)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;1:j++;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;2:j++;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;3:j++;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;4:j++;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;5:j++;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:j++;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;j+x;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p>第三行将输出什么？</p>", "options": [{"option_name": "A", "content": "value=6"}, {"option_name": "B", "content": "value=8"}, {"option_name": "C", "content": "value=3"}, {"option_name": "D", "content": "value=5"}, {"option_name": "E", "content": "value=4"}]}, {"answer": "D", "type": "单选", "name": "<p>init启动进程需要读取()配置文件</p>", "options": [{"option_name": "A", "content": "/sbin/init"}, {"option_name": "B", "content": "/bin/sh"}, {"option_name": "C", "content": "/etc/sysvinit"}, {"option_name": "D", "content": "/etc/inittab"}]}, {"answer": "C", "type": "单选", "name": "<p>以下程序执行的结果是：<br></p><pre class=\"brush:java;toolbar:false\">class&nbsp;X{\r\n&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;y=new&nbsp;Y();\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;X(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(\"X\");\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}\r\nclass&nbsp;Y{\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Y(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(\"Y\");\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}\r\npublic&nbsp;class&nbsp;Z&nbsp;extends&nbsp;X{\r\n&nbsp;&nbsp;&nbsp;&nbsp;Y&nbsp;y=new&nbsp;Y();\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Z(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(\"Z\");\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Z();\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p>&nbsp;</p>", "options": [{"option_name": "A", "content": "ZYXX"}, {"option_name": "B", "content": "ZYXY"}, {"option_name": "C", "content": "YXYZ<br>"}, {"option_name": "D", "content": "XYZX"}]}, {"answer": "D", "type": "单选", "name": "<p>有关线程的叙述正确的是()</p>", "options": [{"option_name": "A", "content": "可以获得对任何对象的互斥锁定"}, {"option_name": "B", "content": "通过继承Thread类或实现Runnable接口，可以获得对类中方法的互斥锁定"}, {"option_name": "C", "content": "线程通过调用对象的synchronized方法可获得对象的互斥锁定"}, {"option_name": "D", "content": "线程调度算法是平台独立的"}]}, {"answer": "A", "type": "单选", "name": "<p>以下关于java封装的描述中，正确的是：</p>", "options": [{"option_name": "A", "content": "封装的主要作用在于对外隐藏内部实现细节，增强程序的安全性"}, {"option_name": "B", "content": "封装的意义不大，因此在编码中尽量不要使用"}, {"option_name": "C", "content": "如果子类继承父类，对于父类中进行封装的方法，子类仍然可以直接调用"}, {"option_name": "D", "content": "只能对一个类中的方法进行封装，不能对属性进行封装"}]}], "company": "爱奇艺", "name": "爱奇艺2016校园招聘 Java研发工程师", "id": "72"}