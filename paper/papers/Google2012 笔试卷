{"url": "http://exercise.acmcoder.com/comp_test?paperId=145", "content": [{"answer": "D", "type": "单选", "name": "<p>下面关于垃圾收集的描述哪个是错误的？</p>", "options": [{"option_name": "A", "content": "使用垃圾收集的程序不需要明确释放对象"}, {"option_name": "B", "content": "现代垃圾收集能够处理循环引用问题"}, {"option_name": "C", "content": "垃圾收集能提高程序员效率"}, {"option_name": "D", "content": "使用垃圾收集的语言没有内在泄漏问题"}]}, {"answer": "A", "type": "单选", "name": "<p>以下算法不能用于文本加密的是：</p>", "options": [{"option_name": "A", "content": "MD5"}, {"option_name": "B", "content": "RSA"}, {"option_name": "C", "content": "RC4"}, {"option_name": "D", "content": "DES"}]}, {"answer": "D", "type": "单选", "name": "<p>与十进制数28.5625相等的四进制数是（ &nbsp; &nbsp;）</p>", "options": [{"option_name": "A", "content": "121.3"}, {"option_name": "B", "content": "221.3"}, {"option_name": "C", "content": "121.31"}, {"option_name": "D", "content": "130.21"}]}, {"answer": "A", "type": "单选", "name": "<p>下列关于整数的说法中哪个是正确的？</p>", "options": [{"option_name": "A", "content": "在采用补码的计算机的系统中，无符号整数和有符号整数很容易区分开"}, {"option_name": "B", "content": "在32位系统中计算8位加法会比32位加法快"}, {"option_name": "C", "content": "作整数运算时应尽量避免溢出，因为溢出会占用额外的内存，影响系统性能"}, {"option_name": "D", "content": "常见计算机系统中整数除法比乘法慢"}]}, {"answer": "C", "type": "单选", "name": "<p>按照OSI模型的层次概念，下列几个协议中哪一个协议在协议栈的最底层?</p>", "options": [{"option_name": "A", "content": "HTTP"}, {"option_name": "B", "content": "FTP"}, {"option_name": "C", "content": "IP"}, {"option_name": "D", "content": "TCP"}]}, {"answer": "D", "type": "单选", "name": "<p>由3个a,5个b和2个c构成的所有长度为10的字符串中，包含子串\"abc\"的共有几个？</p>", "options": [{"option_name": "A", "content": "40320"}, {"option_name": "B", "content": "39600"}, {"option_name": "C", "content": "840"}, {"option_name": "D", "content": "780"}, {"option_name": "E", "content": "60"}]}, {"answer": "B", "type": "单选", "name": "<p>请阅读下面代码片段并且回答问题：<br></p><pre class=\"brush:cpp;toolbar:false\">#define&nbsp;SIZE_20M&nbsp;(20*1024*1024)\r\nvoid&nbsp;func_a()\r\n{\r\n&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*temp&nbsp;=&nbsp;malloc(SIZE_20M)\r\n&nbsp;&nbsp;&nbsp;&nbsp;return;\r\n}\r\nvoid&nbsp;func_b()\r\n{\r\n&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;temp[SIZE_20M];\r\n&nbsp;&nbsp;&nbsp;&nbsp;//...do&nbsp;something&nbsp;using&nbsp;temp\r\n&nbsp;&nbsp;&nbsp;&nbsp;return;\r\n}</pre><p>关于这段代码，下列说法正确的是( &nbsp; &nbsp;)</p>", "options": [{"option_name": "A", "content": "func_a 获得临时内存的方式效率通常更高"}, {"option_name": "B", "content": "func_b 使用了太多的栈，程序可能会在运行时候崩溃"}, {"option_name": "C", "content": "func_b 存在内存泄露"}, {"option_name": "D", "content": "func_a 和func_b 分配的内存会自动初始化0"}]}, {"answer": "D", "type": "单选", "name": "<p>下面关于操作系统的概念，哪个是错误的？</p>", "options": [{"option_name": "A", "content": "Micro-kernel和Monolithic-kernel都还是现代操作系统的常用技术"}, {"option_name": "B", "content": "操作系统为应用软件提供运行环境"}, {"option_name": "C", "content": "操作系统的系统调用是应用软件与操作系统交互的接口"}, {"option_name": "D", "content": "文件系统和设备驱动必须运行在内核态"}]}, {"answer": "B", "type": "单选", "name": "<p>一棵树（&gt;=3个节点）最少需要删掉几个节点才能使得这棵树不连通？</p>", "options": [{"option_name": "A", "content": "0"}, {"option_name": "B", "content": "1"}, {"option_name": "C", "content": "2"}, {"option_name": "D", "content": "3"}]}, {"answer": "D", "type": "单选", "name": "<p>一个有n个结点的连通图的生成树是原图的最小连通子图，且包含原图中所有n个结点，并且有保持图联通的最少的边。最大生成树就是权和最大生成树，现在给出一个无向带权图的邻接矩阵，权为0表示没有边。｛{0，4，5，0，3}，{4，0，4，2，3}，{5，4，0，2，0}，{0，2，2，0，1}，{3，3，0，1，0}｝，求这个图的最大生成树的权和。</p>", "options": [{"option_name": "A", "content": "11"}, {"option_name": "B", "content": "12"}, {"option_name": "C", "content": "13"}, {"option_name": "D", "content": "14"}, {"option_name": "E", "content": "15"}]}], "company": "谷歌", "name": "Google2012 笔试卷", "id": "145"}