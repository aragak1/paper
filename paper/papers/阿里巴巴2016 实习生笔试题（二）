{"year": "2016", "url": "http://exercise.acmcoder.com/comp_test?paperId=76", "content": [{"answer": "F", "type": "单选", "name": "<p>由权值分别为1、12、13、4、8的叶子节点生成一颗哈夫曼树，它的带权路径长度为()</p>", "options": [{"option_name": "A", "content": "12<br>"}, {"option_name": "B", "content": "68<br>"}, {"option_name": "C", "content": "43<br>"}, {"option_name": "D", "content": "6<br>"}, {"option_name": "E", "content": "25<br>"}, {"option_name": "F", "content": "81<br>"}]}, {"answer": "C", "type": "单选", "name": "<p>二叉树的第I层上含有的结点数最多为()</p>", "options": [{"option_name": "A", "content": "2<sup>I</sup>"}, {"option_name": "B", "content": "2<sup>I-1</sup>-1"}, {"option_name": "C", "content": "2<sup>I-1</sup>"}, {"option_name": "D", "content": "2<sup>I</sup>-1"}]}, {"type": "判断", "name": "<p>B-树的插入算法中,通过结点的向上\"分裂\",代替了专门的平衡调整()</p>"}, {"answer": "C", "type": "单选", "name": "<p>下面有关序列模式挖掘算法的描述，错误的是？</p>", "options": [{"option_name": "A", "content": "AprioriAll算法和GSP算法都属于Apriori类算法，都要产生大量的候选序列"}, {"option_name": "B", "content": "FreeSpan算法和PrefixSpan算法不生成大量的候选序列以及不需要反复扫描原数据库"}, {"option_name": "C", "content": "在时空的执行效率上，FreeSpan比PrefixSpan更优"}, {"option_name": "D", "content": "和AprioriAll相比，GSP的执行效率比较高"}]}, {"answer": "C", "type": "单选", "name": "<p>以下几种模型方法属于判别式模型的有</p><p>1)混合高斯模型</p><p>2)条件随机场模型</p><p>3)区分度训练</p><p>4)隐马尔科夫模型</p>", "options": [{"option_name": "A", "content": "1,4"}, {"option_name": "B", "content": "3,4"}, {"option_name": "C", "content": "2,3"}, {"option_name": "D", "content": "1,2"}]}, {"answer": "C", "type": "单选", "name": "<p>下面有关分类算法的准确率，召回率，F1值的描述，错误的是？</p>", "options": [{"option_name": "A", "content": "准确率是检索出相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率"}, {"option_name": "B", "content": "召回率是指检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率"}, {"option_name": "C", "content": "正确率、召回率和 F 值取值都在0和1之间，数值越接近0，查准率或查全率就越高"}, {"option_name": "D", "content": "为了解决准确率和召回率冲突问题，引入了F1分数"}]}, {"answer": "A", "type": "单选", "name": "<p>在分类问题中,我们经常会遇到正负样本数据量不等的情况,比如正样本为10w条数据,负样本只有1w条数据,以下最合适的处理方法是()</p>", "options": [{"option_name": "A", "content": "将负样本重复10次,生成10w样本量,打乱顺序参与分类"}, {"option_name": "B", "content": "直接进行分类,可以最大限度利用数据"}, {"option_name": "C", "content": "从10w正样本中随机抽取1w参与分类"}, {"option_name": "D", "content": "将负样本每个权重设置为10,正样本权重为1,参与训练过程"}]}, {"answer": "F", "type": "单选", "name": "<p>阿里巴巴国际站的股票代码是1688，这个数字具有这样的特性，首先是个首位为1的4位数，其次恰巧有且仅有1个数字出现了两次。类似的数字还有：1861,1668等。这样的数字一共有()个。</p>", "options": [{"option_name": "A", "content": "144<br>"}, {"option_name": "B", "content": "180<br>"}, {"option_name": "C", "content": "216<br>"}, {"option_name": "D", "content": "270"}, {"option_name": "E", "content": "288<br>"}, {"option_name": "F", "content": "432<br>"}]}, {"answer": "B", "type": "单选", "name": "<p>下面哪一个不是动态链接库的优点？</p>", "options": [{"option_name": "A", "content": "共享<br>"}, {"option_name": "B", "content": "装载速度快<br>"}, {"option_name": "C", "content": "开发模式好<br>"}, {"option_name": "D", "content": "减少页面交换<br>"}]}, {"answer": "B", "type": "单选", "name": "<p>深度学习是当前很热门的机器学习算法。在深度学习中，涉及到大量矩阵相乘，现在需要计算三个稠密矩阵A,B,C的乘积ABC，假设三个矩阵的尺寸分别为m*n,n*p,p*q,且m&lt;n&lt;p&lt;q，以下计算顺序效率最高的是：（）</p>", "options": [{"option_name": "A", "content": "A(BC)"}, {"option_name": "B", "content": "(AB)C"}, {"option_name": "C", "content": "(AC)B"}, {"option_name": "D", "content": "所有效率都相同"}]}, {"answer": "D", "type": "单选", "name": "<p>下列时间序列模型中,哪一个模型可以较好地拟合波动性的分析和预测</p>", "options": [{"option_name": "A", "content": "AR模型"}, {"option_name": "B", "content": "MA模型"}, {"option_name": "C", "content": "ARMA模型"}, {"option_name": "D", "content": "GARCH模型"}]}, {"answer": "A", "type": "单选", "name": "<p>在Logistic Regression 中,如果同时加入L1和L2范数,会产生什么效果()</p>", "options": [{"option_name": "A", "content": "可以做特征选择,并在一定程度上防止过拟合"}, {"option_name": "B", "content": "能解决维度灾难问题"}, {"option_name": "C", "content": "能加快计算速度"}, {"option_name": "D", "content": "可以获得更准确的结果"}]}, {"answer": "C", "type": "单选", "name": "<p>下面关于B-和B+树的叙述中，不正确的是</p>", "options": [{"option_name": "A", "content": "B-树和B+树都是平衡的多叉树"}, {"option_name": "B", "content": "B-树和B+树都可用于文件的索引结构"}, {"option_name": "C", "content": "B-树和B+树都能有效地支持顺序检索"}, {"option_name": "D", "content": "B-树和B+树都能有效地支持随机检索"}]}, {"type": "判断", "name": "<p>在图G的最小生成树G1中,可能会有某条边的权值超过未选边的权值()</p>"}, {"answer": "B", "type": "单选", "name": "<p>下列不是进程间的通信方式的是（）</p>", "options": [{"option_name": "A", "content": "管道"}, {"option_name": "B", "content": "回调"}, {"option_name": "C", "content": "共享内存"}, {"option_name": "D", "content": "消息队列"}, {"option_name": "E", "content": "socket"}, {"option_name": "F", "content": "信号量"}]}, {"type": "判断", "name": "<p>二叉树是度为2的有序树()</p>"}, {"type": "判断", "name": "<p>堆是满二叉树()</p>"}, {"answer": "E", "type": "单选", "name": "<p>n个数值选出最大m个数（3&lt;m&lt;n）的最小算法复杂度是</p>", "options": [{"option_name": "A", "content": "O(n)"}, {"option_name": "B", "content": "O(nlogn)"}, {"option_name": "C", "content": "O(logn)<br>"}, {"option_name": "D", "content": "O(mlogn)"}, {"option_name": "E", "content": "O(nlogm)"}, {"option_name": "F", "content": "O(mn)<br>"}]}, {"answer": "C", "type": "单选", "name": "<p>对二叉树的结点从1开始进行连续编号,要求每个结点的编号大于其左、右孩子的编号,在同一结点的左、右孩子中,其左孩子的编号小于其右孩子的编号,可采用()次序的遍历实现编号</p>", "options": [{"option_name": "A", "content": "前序"}, {"option_name": "B", "content": "中序"}, {"option_name": "C", "content": "后序"}, {"option_name": "D", "content": "从根开始按层次遍历"}]}, {"answer": "B", "type": "单选", "name": "<p>类域界面方程法中，不能求线性不可分情况下分类问题近似或精确解的方法是？</p>", "options": [{"option_name": "A", "content": "伪逆法"}, {"option_name": "B", "content": "感知器算法"}, {"option_name": "C", "content": "基于二次准则的H-K算法"}, {"option_name": "D", "content": "势函数法"}]}, {"answer": "A", "type": "单选", "name": "<p>已知IBM的PowerPC是big-endian字节序列而Intel的X86是little-endian字节序，如果在地址啊存储的整形值时0x04030201，那么地址为a+3的字节内存储的值在PowerPC和Intel X86结构下的值分别是？</p>", "options": [{"option_name": "A", "content": "1 4"}, {"option_name": "B", "content": "1 3"}, {"option_name": "C", "content": "4 1"}, {"option_name": "D", "content": "3 1"}, {"option_name": "E", "content": "4 4"}, {"option_name": "F", "content": "1 1"}]}, {"answer": "C", "type": "单选", "name": "<p>以下哪个是常见的时间序列算法模型</p>", "options": [{"option_name": "A", "content": "RSI"}, {"option_name": "B", "content": "MACD"}, {"option_name": "C", "content": "ARMA"}, {"option_name": "D", "content": "KDJ"}]}, {"answer": "C", "type": "单选", "name": "<p>关于支持向量机SVM,下列说法错误的是（）</p>", "options": [{"option_name": "A", "content": "L2正则项，作用是最大化分类间隔，使得分类器拥有更强的泛化能力"}, {"option_name": "B", "content": "Hinge 损失函数，作用是最小化经验分类错误"}, {"option_name": "C", "content": "分类间隔为1/||w||，||w||代表向量的模"}, {"option_name": "D", "content": "当参数C越小时，分类间隔越大，分类错误越多，趋于欠学习"}]}, {"answer": "C", "type": "单选", "name": "<p>如下表是用户是否使用某产品的调查结果（）&nbsp;</p><p>UID 年龄 地区 学历 收入 用户是否使用调查产品</p><p>1 低 北方 博士 低 是</p><p>2 高 北方 本科 中 否</p><p>3 低 南方 本科 高 否</p><p>4 高 北方 研究生 中 是</p><p>请计算年龄，地区，学历，收入中对用户是否使用调查产品信息增益最大的属性（Log23≈0.63）</p>", "options": [{"option_name": "A", "content": "年龄"}, {"option_name": "B", "content": "地区"}, {"option_name": "C", "content": "学历"}, {"option_name": "D", "content": "收入"}]}], "company": "阿里巴巴", "name": "阿里巴巴2016 实习生笔试题（二）", "id": "76"}